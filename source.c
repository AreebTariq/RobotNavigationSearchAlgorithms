/********************************************************************************************************************

***********************************
PROGRAM: ROBOT NAVIGATION PROBLEM *
***********************************

CREATED BY: AREEB TARIQ
DATE: DECEMBER 26 2021

DESCRIPTION:
____________
	This program implements following search algorithms to navigate the robot to the goal position.
		a. Breadth first Search
		b. Uniform cost search
		c. Depth first search
		d. Iterative deepening
		e. Greedy search
		f. A* search

	The size of the rectangular grid (space) is user defined NxN.
	The permission of diagonal movement in a grid is a choice of the user
	In case diagonal movement is allowed, user can choose the cost of diagonal movement either 1 or 1.5

PROCESS FLOW:
_____________
	
	1. The program sequentially asks for following initial information before proceeding with the search algorithm:
		a. Grid Size
		b. Grid (consisting of empty cells indicated by '.' and obstacles indicated by 'X')
		c. Robot Position (Rows: 1-N from bottom-to-top respectively. Colums: 1-N from left-to-right respectively)
		d. Goal Position (With same convention as robot position)
		e. Diagonal movement allowed: yes or no
		f. Cost of diagonal movement (if diagonal movment is allowed): 1 or 1.5
		g. Choice of search method from the list given in the description above
	
	
	2. After getting the information, program executes the respective search algorithm.
	
	3. At each step it shows the state of fringe, and list of expanded nodes.
	
	4. If successfully finds the path to goal position, the program provides the following output statistics:
		a. Cost from the robot initial position to the goal position 
		b. Total number of nodes generated in this process
		c. Total number of expanded nodes in this process
		f. Path consisting of initial node, intermediate node(s), and goal node 

	5. If there is no path possible, program will respond with no possible result.

	6. After this, program will offer three choices to the user:
		a. To provide the new grid
		b. Search again on the same grid 
		c. Exit

		Based on the response, program executes accordingly.
*********************************************************************************************************************/

/*Include header files needed for the implementation*/
#include"stdio.h"
#include"stdbool.h"
#include"queue.h"
#include"string.h"
#include"stdlib.h"

#pragma warning(disable : 4996)

/******************/
/*Global MACROS*/
/******************/


#define ZERO 0														/*Macro for magic number '0'*/
#define ONE 1														/*Macro for magic number '1'*/
#define TWO 2														/*Macro for magic number '2'*/
#define INVALID_VALUE 0xFFFFFF										/*An invalid value macro*/
#define DEFAULT_DIAGONAL_MOVEMENT_COST 1							/*Default value of the diagonal movement*/
#define DIAGONAL_MOVEMENT_COST_MAX     1.5							/*Default value of the diagonal movement*/
#define DEFAULT_INITIAL_COST_OF_NODE 0								/*Default initial cost of selecting a node position*/
#define MAX_INPUT_ATTEMPTS 3										/*Macro to control maximum number of retries if user enteres an invalid input*/
#define MANHATTAN_DISTANCE 1										/*Value for the Manhattan distance heuristic selection in informed searches*/
#define CHEBYSHEV_DISTANCE 2										/*Value for the Chebyshev distance heuristic selection in informed searches*/

/**************************************/
/*Global variables and Data Structures*/
/**************************************/

Node_Coordinates robot_mapped_coordinates;							/*Coordinates of the robot position mapped to the program implementation*/
Node_Coordinates goal_mapped_coordinates;							/*Coordinates of the goal position mapped to the program implementation*/
int total_number_of_generated_nodes = ZERO;							/*Counter for the total number of nodes generated by the given algorithm*/
int grid_size;														/*Dimension N to for grid NxN */
int selected_heuristic_type = INVALID_VALUE;						/*Indicates the current heuristic type*/
bool explored_full_tree;											/*Flag to indicate whether the tree is completely exhausted/explored in iterative deepening search*/
char* diagonal_movement_allowed;									/*Holds the diagnoal movement status (allowed values: yes/no)*/
float diagonal_movement_cost = DEFAULT_DIAGONAL_MOVEMENT_COST;		/*Cost of the diagonal movement, by default = 1, allowed values: 1, 1.5*/

/*Depth limited search possible outcomes. Used in iterative deepening search*/
typedef enum Depth_limited_result
{
	SUCCESS,
	FAILURE,
	CUT_OFF
}Depth_limited_result;

/*Node or element in a 2D rectangular grid*/
typedef struct
{
	Node_Coordinates cell_coordinates;
	char cell_type;
	float cost;
	Queue* successors;
}Grid_Node;

typedef struct
{
	float cost_from_root;
	Node_Coordinates node_coordinates;
	Node_Coordinates parent_corrdinates;
}Succ_node;

Queue* fringe;														/*Dynamic fringe, implemented as queue*/
Queue* expanded_nodes;												/*List of expanded nodes*/
Queue* path;														/*List of sequentially connected nodes forming a path from robot position to goal position*/
Grid_Node** grid;													/*NxN grid*/
Node_Coordinates dummy_invalid_coordinates;


/*****************************************************************************
* Function Description:
* 
* Verifies the entered_value validity with valid_ref
* Returns: true if entered_value is valid, else returns false
******************************************************************************/
bool valid_input(int entered_value, int valid_ref)
{
	if (entered_value < ZERO)
	{
		return false;
	}
	if (entered_value == valid_ref)
	{
		return true;
	}
	else
	{
		return false;
	}
}

/*****************************************************************************
* Function Description:
*
* Checks if the given node/element in grid is obstacle or not
* Returns: true if given node is obstacle, else returns false
******************************************************************************/
bool check_obstacle(Node_Coordinates node_coordinates)
{
	if (grid[node_coordinates.row][node_coordinates.column].cell_type == 'X' || grid[node_coordinates.row][node_coordinates.column].cell_type == 'x')
	{
		return true;
	}
	else
	{
		return false;
	}
}

/*****************************************************************************
* Function Description:
*
* Initializes the NxN grid. Cleans all its nodes and their respective data
******************************************************************************/
void reset_grid()
{
	for (int i = 0; i < grid_size; i++)
	{
		for (int j = 0;j < grid_size;j++)
		{
			grid[i][j].cell_coordinates.row		= INVALID_VALUE;
			grid[i][j].cell_coordinates.column  = INVALID_VALUE;
			grid[i][j].cell_type				= INVALID_VALUE;
			grid[i][j].cost						= DEFAULT_INITIAL_COST_OF_NODE;
		}
		free(grid[i]);
	}
	free(grid);
	grid_size = ZERO;
}

/*****************************************************************************
* Function Description:
*
* Initializes the program by resetting the common global parameters
******************************************************************************/
void reset_parameters()
{
	robot_mapped_coordinates.row	= INVALID_VALUE;
	robot_mapped_coordinates.column = INVALID_VALUE;
	goal_mapped_coordinates.row		= INVALID_VALUE;
	goal_mapped_coordinates.column	= INVALID_VALUE;

	diagonal_movement_cost = 1;
	total_number_of_generated_nodes = ZERO;
	explored_full_tree = false;
	selected_heuristic_type = INVALID_VALUE;

	for (int i = 0; i < grid_size; i++)
	{
		for (int j = 0;j < grid_size;j++)
		{
			grid[i][j].cost = DEFAULT_INITIAL_COST_OF_NODE;
			delete_queue(grid[i][j].successors);
		}
	}
	delete_queue(fringe);
	delete_queue(expanded_nodes);
	delete_queue(path);
}

/*****************************************************************************
* Function Description:
*
* Verifies the entered_value validity with valid_ref
* Returns: true if entered_value is valid, else returns false
******************************************************************************/
bool is_expanded_node(Node_Coordinates node_coordinates)
{
	if (expanded_nodes->size == 0)
	{
		return false;
	}
	QNode* temp = expanded_nodes->front;
	for (int i = 0; i <expanded_nodes->size ;i++)
	{
		if (temp->node_coordinates.row == node_coordinates.row && temp->node_coordinates.column == node_coordinates.column)
		{
			return true;
		}
		temp = temp->next;
	}
	return false;
}

/*****************************************************************************
* Function Description:
*
* Verifies the given node is currently present in the fringe or not
* Returns: true if node is present in fringe, else returns false
******************************************************************************/
bool is_node_already_present_in_fringe(Node_Coordinates node_coordinates)
{
	QNode* temp = fringe->front;
	for (int i = 0; i < fringe->size;i++)
	{
		if (temp->node_coordinates.row == node_coordinates.row && temp->node_coordinates.column == node_coordinates.column)
		{
			return true;
		}
		temp = temp->next;
	}
	return false;
}

/*****************************************************************************
* Function Description:
*
* Calculate the manhattan distance from current position to goal position.
******************************************************************************/
float calculate_manhattan_distance(Node_Coordinates current_position, Node_Coordinates goal_position)
{
	float dx, dy;
	dx = abs(current_position.column - goal_position.column);
	dy = abs(current_position.row - goal_position.row);

	return dx + dy;
}

/*****************************************************************************
* Function Description:
*
* Calculate the chebyshev distance from current position to goal position.
******************************************************************************/
float calculate_chebyshev_distance(Node_Coordinates current_position, Node_Coordinates goal_position)
{
	float dx, dy;
	dx = abs(current_position.column - goal_position.column);
	dy = abs(current_position.row - goal_position.row);

	if (dx > dy)
	{
		return dx;
	}
	else
	{
		return dy;
	}
}

/*****************************************************************************
* Function Description:
*
* Calculate the heuristic value from current position to goal position using,
* heuristic mentioned in the input/argument. 
*	1. Manhattan distance heuristic
*	2. Chebyshev distance heuristic
******************************************************************************/
float calculate_heuristic(Node_Coordinates current_position, Node_Coordinates goal_position, int heuristic_type)
{
	float heuristic_value = INVALID_VALUE;

	if (heuristic_type == MANHATTAN_DISTANCE)
	{
		heuristic_value = calculate_manhattan_distance(current_position,goal_position);
	}
	else if (heuristic_type == CHEBYSHEV_DISTANCE)
	{
		heuristic_value = calculate_chebyshev_distance(current_position, goal_position);
	}
	return heuristic_value;
}
/*****************************************************************************
* Function Description:
*
* Adds the given node to the list of expanded nodes.
* This is done after the node has been expanded in a search process
******************************************************************************/
void add_node_to_expanded_list(Node_Coordinates node_coordinates, Node_Coordinates parent_coordinates)
{
	add_end_of_queue(expanded_nodes, node_coordinates, INVALID_VALUE, parent_coordinates, INVALID_VALUE, INVALID_VALUE);
}

/*****************************************************************************
* Function Description:
*
* Displays the current list of expanded nodes on console
******************************************************************************/
void print_expanded_nodes()
{
	QNode* temp = expanded_nodes->front;

	/*INSTRUCTIONS ON CONSOLE FOR THE USER TO UNDERSTAND THE EXPANDED NODES REPPRESENTATION ON THE GRID*/
	printf("\033[0;36m");
	printf("\nLetter 'E' indicates the expanded nodes in the grid\n");
	printf("\033[0m");

	/*Prepare grid with path to display*/
	for (int i = 0; i < expanded_nodes->size; i++)
	{
		int mapped_row = temp->node_coordinates.row;
		int mapped_col = temp->node_coordinates.column;

		grid[mapped_row][mapped_col].cell_type = 'E';
		temp = temp->next;
	}

	/*Display the grid with path*/
	printf("\n  ");
	for (int i = 0;i < grid_size;i++)
	{
		printf("    %d", i + 1);
	}
	printf("\n");
	for (int i = 0;i < grid_size;i++)
	{
		printf("________");
	}

	for (int i = 0;i < grid_size;i++)
	{
		printf("\t\n |\n |\n%d|    ", grid_size - i);
		for (int j = 0;j < grid_size;j++)
		{
			if (grid[i][j].cell_type == 'E')
			{
				printf("\033[0;36m");
				printf("%c    ", grid[i][j].cell_type);
				printf("\033[0m");
			}
			else
			{
				printf("%c    ", grid[i][j].cell_type);
			}
		}
	}
	printf("\n\n");

	/*Bring grid to normal state without path*/
	temp = expanded_nodes->front;
	for (int i = 0; i < expanded_nodes->size; i++)
	{
		int mapped_row = temp->node_coordinates.row;
		int mapped_col = temp->node_coordinates.column;

		grid[mapped_row][mapped_col].cell_type = '.';
		temp = temp->next;
	}
}

/*****************************************************************************
* Function Description:
*
* Displays the current nodes in the fringe
******************************************************************************/
void display_fringe()
{
	QNode* temp = fringe->front;

	/*INSTRUCTIONS ON CONSOLE FOR THE USER TO UNDERSTAND THE FRINGE REPPRESENTATION ON THE GRID*/
	printf("\033[0;33m");
	printf("\nLetter 'F' indicates the nodes present in the fringe within a grid\n");
	printf("\033[0m");

	/*Prepare grid with path to display*/
	for (int i = 0; i < fringe->size; i++)
	{
		int mapped_row = temp->node_coordinates.row;
		int mapped_col = temp->node_coordinates.column;

		grid[mapped_row][mapped_col].cell_type = 'F';
		temp = temp->next;
	}

	/*Display the grid with path*/
	printf("\n  ");
	for (int i = 0;i < grid_size;i++)
	{
		printf("    %d", i + 1);
	}
	printf("\n");
	for (int i = 0;i < grid_size;i++)
	{
		printf("________");
	}

	for (int i = 0;i < grid_size;i++)
	{
		printf("\t\n |\n |\n%d|    ", grid_size - i);
		for (int j = 0;j < grid_size;j++)
		{
			if (grid[i][j].cell_type == 'F')
			{
				printf("\033[0;33m");
				printf("%c    ", grid[i][j].cell_type);
				printf("\033[0m");
			}
			else
			{
				printf("%c    ", grid[i][j].cell_type);
			}
		}
	}
	printf("\n\n");

	/*Bring grid to normal state without path*/
	temp = fringe->front;
	for (int i = 0; i < fringe->size; i++)
	{
		int mapped_row = temp->node_coordinates.row;
		int mapped_col = temp->node_coordinates.column;

		grid[mapped_row][mapped_col].cell_type = '.';
		temp = temp->next;
	}
}

/**************************************************************************************************************
* Function Description:
*
* Verifies without expanding whether successors present from the given node
* This is crucial to differentiate between exhausted and non-exhausted path during iterative deepening search
* Returns: true if successors are present (non-exhausted path), else (exhausted path) returns false
**************************************************************************************************************/
bool are_successors_present(Node_Coordinates node_coordinates, int grid_order)
{
	Node_Coordinates next_coordinates;
	int current_row = node_coordinates.row;
	int current_col = node_coordinates.column;
	bool result = false;
	
	/*Case-1: Increment row*/
	next_coordinates.row = current_row + 1;
	if (next_coordinates.row >= ZERO && next_coordinates.row <= grid_order - 1)
	{
		/*Case-1a: Column remains same*/
		next_coordinates.column = current_col;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe (next_coordinates))
		{
			return true;
		}

		/*If diagonal is allowed*/
		if (strcmp(diagonal_movement_allowed, "yes") == 0)
		{
			/*Case-1b: Increment column*/
			next_coordinates.column = current_col + 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
				{
					return true;
				}
			}

			/*Case-1c: Decrement column*/
			next_coordinates.column = current_col - 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
				{
					return true;
				}
			}
		}
	}

	/*Case-2: Decrement row*/
	next_coordinates.row = current_row - 1;
	if (next_coordinates.row >= ZERO && next_coordinates.row <= grid_order - 1)
	{
		/*Case-2a: Column remains same*/
		next_coordinates.column = current_col;
		
		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
		{
			return true;
		}

		/*If diagonal is allowed*/
		if (strcmp(diagonal_movement_allowed, "yes") == 0)
		{
			/*Case-2b: Increment column*/
			next_coordinates.column = current_col + 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
				{
					return true;
				}
			}

			/*Case-2c: Decrement column*/
			next_coordinates.column = current_col - 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
				{
					return true;
				}
			}
		}
	}

	/*Case-3: Row remains same, Increment column*/
	next_coordinates.row = current_row;
	next_coordinates.column = current_col + 1;

	if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
	{
		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
		{
			return true;
		}

	}

	/*Case-4: Row remains same, Decrement column*/
	next_coordinates.row = current_row;
	next_coordinates.column = current_col - 1;

	if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
	{
		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(next_coordinates) && !is_expanded_node(next_coordinates) && !is_node_already_present_in_fringe(next_coordinates))
		{
			return true;
		}
	}
	return result;
}

/*****************************************************************************
* Function Description:
*
* Generates the path from robot position to goal position by backtracking 
******************************************************************************/
void generate_the_path(Node_Coordinates parent_coordinates)
{
	while (parent_coordinates.row != INVALID_VALUE && parent_coordinates.column != INVALID_VALUE)
	{
		QNode* temp = expanded_nodes->front;
		for (int i = 0; i < expanded_nodes->size;i++)
		{
			if (temp->node_coordinates.row == parent_coordinates.row && temp->node_coordinates.column == parent_coordinates.column)
			{
				add_front_of_queue(path, temp->node_coordinates,INVALID_VALUE,  dummy_invalid_coordinates, INVALID_VALUE, INVALID_VALUE);
				parent_coordinates.row		= temp->parent_node_coordinates.row;
				parent_coordinates.column	= temp->parent_node_coordinates.column;
				break;
			}
			temp = temp->next;
		}
	}
}

/*****************************************************************************
* Function Description:
*
* Generates and displays the path from the robot position to goal position
******************************************************************************/
void generate_and_print_the_path(Node_Coordinates parent_coordinates)
{
	int temp;
	int xth_step = INVALID_VALUE;			/* Local variable to differentiate between 'step X' and 'obstacle X'*/

	/*Add the goal position at first*/
	add_end_of_queue(path, goal_mapped_coordinates, INVALID_VALUE, dummy_invalid_coordinates, INVALID_VALUE, INVALID_VALUE);

	/*Generate intermediate nodes between goal and robot position by backtracking*/
	generate_the_path(parent_coordinates);

	/*Prepare grid with path to display*/
	QNode* temp_pointer = path->front;
	for (int i = 0; i < path->size; i++)
	{
		int mapped_row = temp_pointer->node_coordinates.row;
		int mapped_col = temp_pointer->node_coordinates.column;

		temp = i + 'A';
		if (temp > 'Z')
		{
			grid[mapped_row][mapped_col].cell_type = (i + 6) + 'A';
		}
		else
		{
			if (temp == 'X')
			{
				xth_step = temp_pointer->node_coordinates.row;
			}
			grid[mapped_row][mapped_col].cell_type = temp;
		}
		temp_pointer = temp_pointer->next;
	}

	/*INSTRUCTIONS ON CONSOLE FOR THE USER TO UNDERSTAND THE PATH REPPRESENTATION ON THE GRID*/
	printf("\033[0;32m");
	printf("\nPATH FOUND!! \nLetter 'A' indicates the initial robot position\nHIGHEST Letter indicates the goal position\n");
	printf("\033[0m");
	printf("\033[0;36m");
	printf("NOTE: If number of steps exceed the Capital English letters, further steps are represented by smaller English letters\nIncremental letters indicate the navigation or path of the robot\n");
	printf("\033[0m");
	
	/*Display the grid with path*/
	printf("\n  ");
	for (int i = 0;i < grid_size;i++)
	{
		printf("    %d", i + 1);
	}
	printf("\n");
	for (int i = 0;i < grid_size;i++)
	{
		printf("________");
	}

	for (int i = 0;i < grid_size;i++)
	{
		printf("\t\n |\n |\n%d|    ", grid_size - i);
		for (int j = 0;j < grid_size;j++)
		{
			if (i == robot_mapped_coordinates.row && j == robot_mapped_coordinates.column)
			{
				printf("\033[0;32m");
				printf("A    ");
				printf("\033[0m");
			}
			else if (i == goal_mapped_coordinates.row && j == goal_mapped_coordinates.column)
			{
				printf("\033[0;32m");
				printf("%c    ", grid[i][j].cell_type);
				printf("\033[0m");
			}
			else
			{
				if (grid[i][j].cell_type != '.')
				{
					if (grid[i][j].cell_type == 'X' && xth_step == INVALID_VALUE)
					{
						printf("%c    ", grid[i][j].cell_type);
					}
					else
					{
						printf("\033[0;32m");
						printf("%c    ", grid[i][j].cell_type);
						printf("\033[0m");
					}
				}
				else
				{
					printf("%c    ", grid[i][j].cell_type);
				}
			}
		}
	}
	printf("\n\n");

	/*Bring grid to normal state without path*/
	temp_pointer = path->front;
	for (int i = 0; i < path->size; i++)
	{
		int mapped_row = temp_pointer->node_coordinates.row;
		int mapped_col = temp_pointer->node_coordinates.column;

		grid[mapped_row][mapped_col].cell_type = '.';

		temp_pointer = temp_pointer->next;
	}
}

/*****************************************************************************
* Function Description:
*
* Generates and add the possible successor child nodes of the given current_node
******************************************************************************/
void find_and_add_successors(Grid_Node* current_node, int grid_order, float prior_cost)
{
	int current_row = current_node->cell_coordinates.row;
	int current_col = current_node->cell_coordinates.column;
	Node_Coordinates next_coordinates;
	Succ_node successor_node;
	float evaluation_function_cost = INVALID_VALUE;

	/*Case-1: Increment row*/
	next_coordinates.row = current_row + 1;
	if (next_coordinates.row >= ZERO && next_coordinates.row <= grid_order - 1)
	{
		/*Case-1a: Column remains same*/
		next_coordinates.column = current_col;

		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node (successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);
			
			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}

		/*If diagonal is allowed*/
		if (strcmp(diagonal_movement_allowed, "yes") == 0)
		{
			/*Case-1b: Increment column*/
			next_coordinates.column = current_col + 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}
			}
			
			/*Case-1c: Decrement column*/
			next_coordinates.column = current_col - 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}
			}
		}
	}

	/*Case-2: Decrement row*/
	next_coordinates.row = current_row - 1;
	if (next_coordinates.row >= ZERO && next_coordinates.row <= grid_order - 1)
	{
		/*Case-2a: Column remains same*/
		next_coordinates.column = current_col;

		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}

		/*If diagonal is allowed*/
		if (strcmp(diagonal_movement_allowed, "yes") == 0)
		{
			/*Case-2b: Increment column*/
			next_coordinates.column = current_col + 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}

			}

			/*Case-2c: Decrement column*/
			next_coordinates.column = current_col - 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}
			}
		}
	}

	/*Case-3: Row remains same, increment column*/
	next_coordinates.row = current_row;
	next_coordinates.column = current_col + 1;

	if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
	{
		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}
	}

	/*Case-4: Row remains same, decrement column*/
	next_coordinates.row = current_row;
	next_coordinates.column = current_col - 1;

	if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
	{
		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates) && !is_node_already_present_in_fringe(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}
	}
}

/*****************************************************************************
* Function Description:
*
* Generates and add the possible successor child nodes of the given current_node
* The difference with other normal successors find function because it doesn't 
* verify the already presence of successors node in fringe. The rationale is to
* later update the previous node in fringe if this new successors offers less cost
******************************************************************************/
void find_and_add_successors_for_uniform_cost_search(Grid_Node* current_node, int grid_order, float prior_cost, bool a_star_search)
{
	int current_row = current_node->cell_coordinates.row;
	int current_col = current_node->cell_coordinates.column;
	Node_Coordinates next_coordinates;
	Succ_node successor_node;
	float evaluation_function_cost = INVALID_VALUE;

	/*Case-1: Increment row*/
	next_coordinates.row = current_row + 1;
	if (next_coordinates.row >= ZERO && next_coordinates.row <= grid_order - 1)
	{
		/*Case-1a: Column remains same*/
		next_coordinates.column = current_col;

		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			if (a_star_search == true)
			{
				evaluation_function_cost += successor_node.cost_from_root;
			}

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}

		/*If diagonal is allowed*/
		if (strcmp(diagonal_movement_allowed, "yes") == 0)
		{
			/*Case-1b: Increment column*/
			next_coordinates.column = current_col + 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					if (a_star_search == true)
					{
						evaluation_function_cost += successor_node.cost_from_root;
					}

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}
			}

			/*Case-1c: Decrement column*/
			next_coordinates.column = current_col - 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					if (a_star_search == true)
					{
						evaluation_function_cost += successor_node.cost_from_root;
					}

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}
			}
		}
	}

	/*Case-2: Decrement row*/
	next_coordinates.row = current_row - 1;
	if (next_coordinates.row >= ZERO && next_coordinates.row <= grid_order - 1)
	{
		/*Case-2a: Column remains same*/
		next_coordinates.column = current_col;

		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			if (a_star_search == true)
			{
				evaluation_function_cost += successor_node.cost_from_root;
			}

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}

		/*If diagonal is allowed*/
		if (strcmp(diagonal_movement_allowed, "yes") == 0)
		{
			/*Case-2b: Increment column*/
			next_coordinates.column = current_col + 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					if (a_star_search == true)
					{
						evaluation_function_cost += successor_node.cost_from_root;
					}

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}

			}

			/*Case-2c: Decrement column*/
			next_coordinates.column = current_col - 1;
			if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
			{
				successor_node.node_coordinates = next_coordinates;

				/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
				if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
				{
					successor_node.cost_from_root = diagonal_movement_cost + prior_cost;
					successor_node.parent_corrdinates = current_node->cell_coordinates;

					evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

					if (a_star_search == true)
					{
						evaluation_function_cost += successor_node.cost_from_root;
					}

					add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
				}
			}
		}
	}

	/*Case-3: Row remains same, increment column*/
	next_coordinates.row = current_row;
	next_coordinates.column = current_col + 1;

	if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
	{
		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			if (a_star_search == true)
			{
				evaluation_function_cost += successor_node.cost_from_root;
			}

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}
	}

	/*Case-4: Row remains same, decrement column*/
	next_coordinates.row = current_row;
	next_coordinates.column = current_col - 1;

	if (next_coordinates.column >= ZERO && next_coordinates.column <= grid_order - 1)
	{
		successor_node.node_coordinates = next_coordinates;

		/*VALID SUCCESSOR: If not an obstacle, not already expanded (to avoid redundant loops), and not currently present in fringe (to avoid dual entry in fringe)*/
		if (!check_obstacle(successor_node.node_coordinates) && !is_expanded_node(successor_node.node_coordinates))
		{
			successor_node.cost_from_root = 1 + prior_cost;
			successor_node.parent_corrdinates = current_node->cell_coordinates;

			evaluation_function_cost = calculate_heuristic(successor_node.node_coordinates, goal_mapped_coordinates, selected_heuristic_type);

			if (a_star_search == true)
			{
				evaluation_function_cost += successor_node.cost_from_root;
			}

			add_end_of_queue(current_node->successors, successor_node.node_coordinates, successor_node.cost_from_root, successor_node.parent_corrdinates, INVALID_VALUE, evaluation_function_cost);
		}
	}
}

/*****************************************************************************
* Function Description:
*
* Updates the node in fringe if the low cost path to this node has been found
* This is used in uniform cost search algorithm
******************************************************************************/
void update_fringe_node_with_less_cost(Queue* fringe, Node_Coordinates node_coordinates, float cost_from_root, Node_Coordinates parent_coordinates, int node_depth, float evaluation_function_cost)
{
	QNode* temp = fringe->front;
	QNode* prev = fringe->front;

	for (int i = 0; i < fringe->size;i++)
	{
		if (temp->node_coordinates.row == node_coordinates.row && temp->node_coordinates.column == node_coordinates.column)
		{
			if (evaluation_function_cost == INVALID_VALUE)
			{			/*If fringe node already has lesser cost, no update is needed*/
				if (temp->cost_from_root <= cost_from_root)
				{
					return;
				}
				if (temp == fringe->front)
				{
					//printf("Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with cost from root = %f needs update\n", temp->node_coordinates.row, temp->node_coordinates.column,
						//temp->parent_node_coordinates.row, temp->parent_node_coordinates.column, temp->cost_from_root);
					remove_front_of_queue(fringe);
				}
				else if (temp == fringe->rear)
				{
					//printf("Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with cost from root = %f needs update\n", temp->node_coordinates.row, temp->node_coordinates.column,
						//temp->parent_node_coordinates.row, temp->parent_node_coordinates.column, temp->cost_from_root);
					prev->next = NULL;
					fringe->rear = prev;
					fringe->size--;
					free(temp);
				}
				else
				{
					//printf("Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with cost from root = %f needs update\n", temp->node_coordinates.row, temp->node_coordinates.column,
						//temp->parent_node_coordinates.row, temp->parent_node_coordinates.column, temp->cost_from_root);
					prev->next = temp->next;
					fringe->size--;
					free(temp);
				}
			}
			else
			{
				/*If fringe node already has lesser cost, no update is needed*/
				if (temp->evaluation_function_cost <= evaluation_function_cost)
				{
					return;
				}
				if (temp == fringe->front)
				{
					//printf("Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with heuristic value = %f needs update\n", 
						//temp->node_coordinates.row, temp->node_coordinates.column,
						//temp->parent_node_coordinates.row, temp->parent_node_coordinates.column, temp->evaluation_function_cost);
					remove_front_of_queue(fringe);
				}
				else if (temp == fringe->rear)
				{
					//printf("Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with heuristic value = %f needs update\n",
						//temp->node_coordinates.row, temp->node_coordinates.column,
						//temp->parent_node_coordinates.row, temp->parent_node_coordinates.column, temp->evaluation_function_cost);
					prev->next = NULL;
					fringe->rear = prev;
					fringe->size--;
					free(temp);
				}
				else
				{
					//printf("Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with heuristic value = %f needs update\n",
						//temp->node_coordinates.row, temp->node_coordinates.column,
						//temp->parent_node_coordinates.row, temp->parent_node_coordinates.column, temp->evaluation_function_cost);
					prev->next = temp->next;
					fringe->size--;
					free(temp);
				}
			}

			break;
		}
		prev = temp;
		temp = temp->next;
	}
	if (evaluation_function_cost == INVALID_VALUE)
	{
		//printf("UPDATED Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with cost from root = %f\n", node_coordinates.row, node_coordinates.column,
			//parent_coordinates.row, parent_coordinates.column, cost_from_root);

	}
	else
	{
		//printf("UPDATED Fringe node with (row,col) = (%d,%d) having parent node (row,col) = (%d,%d) with heuristic value = %f\n", node_coordinates.row, node_coordinates.column,
			//parent_coordinates.row, parent_coordinates.column, evaluation_function_cost);

	}
	/*Update (previously delated, now adding in prioriy queue) the node in the fringe with lesser path cost*/
	add_in_increasing_queue(fringe, node_coordinates, cost_from_root, parent_coordinates, node_depth, evaluation_function_cost);
}

/*****************************************************************************
* Function Description:
*
* Implements the breadth first search algorithm
******************************************************************************/
void breadth_first_search(Queue* fringe, Node_Coordinates goal_coordinates)
{
	/*Displays the fringe*/
	display_fringe(fringe, grid_size);

	/*If fringe is empty, search resulted in no path*/
	if (fringe->size == ZERO)
	{
		printf("\033[0;31m");
		printf("\nNo path exists to the goal position from  the robot position\n");
		printf("\033[0m");

		printf("\033[0;35m");
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");
	}

	else
	{
		/*Get the node present in the front of the fringe*/
		Node_Coordinates current_node = fringe->front->node_coordinates;

		int row = fringe->front->node_coordinates.row;
		int col = fringe->front->node_coordinates.column;

		int prior_depth = fringe->front->depth_of_node;

		/*Expand this node to find the successors*/
		find_and_add_successors(&grid[row][col], grid_size, fringe->front->cost_from_root);

		/*Add this node to expanded list*/
		add_node_to_expanded_list(fringe->front->node_coordinates, fringe->front->parent_node_coordinates);

		/*Print the list of expanded nodes*/
		print_expanded_nodes();
		
		/*Clear this node from the fringe*/
		remove_front_of_queue(fringe);

		/*Navigate through all children/successors*/
		QNode* succ_list_pointer = grid[row][col].successors->front;
		int successors_count = grid[row][col].successors->size;

		for (int i = 0;i < successors_count;i++)
		{
			total_number_of_generated_nodes++;

			if (!is_expanded_node(succ_list_pointer->node_coordinates) && !is_node_already_present_in_fringe(succ_list_pointer->node_coordinates))
			{	
				/*Check if the children/successor is a goal node, display the path from robot initial position to goal poisition and return success*/
				if (succ_list_pointer->node_coordinates.row == goal_coordinates.row && succ_list_pointer->node_coordinates.column == goal_coordinates.column)
				{
					display_fringe(fringe, grid_size);

					printf("\033[0;35m");
					printf("\nTotal cost = %f\n", succ_list_pointer->cost_from_root);
					printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
					printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
					printf("\033[0m");

					generate_and_print_the_path(succ_list_pointer->parent_node_coordinates);
					return;
				}

				/*If this node is not already expanded or already present in the fringe, add this to end of fringe for FIFO implementation*/
				else
				{
					add_end_of_queue(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, INVALID_VALUE);
				}		
			}
			succ_list_pointer = succ_list_pointer->next;
		}
		/*Recursive call*/
		breadth_first_search(fringe, goal_coordinates);
	}
}

/*****************************************************************************
* Function Description:
*
* Implements the uniform cost search algorithm
******************************************************************************/
void uniform_cost_search(Queue* fringe, Node_Coordinates goal_coordinates)
{
	/*Displays the fringe*/
	display_fringe(fringe, grid_size);

	/*If fringe is empty, search resulted in no path*/
	if (fringe->size == ZERO)
	{
		printf("\033[0;31m");
		printf("\nNo path exists to the goal position from  the robot position\n");
		printf("\033[0m");
		printf("\033[0;35m");
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");
		return;
	}

	/*Get the node present in the front of the fringe*/
	Node_Coordinates current_node = fringe->front->node_coordinates;

	int row = fringe->front->node_coordinates.row;
	int col = fringe->front->node_coordinates.column;

	/*If this node is a goal node, display the path from robot initial position to goal poisition and return success*/
	if (row == goal_coordinates.row && col == goal_coordinates.column)
	{
		printf("\033[0;35m");
		printf("\nTotal cost = %f\n", fringe->front->cost_from_root);
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");

		generate_and_print_the_path(fringe->front->parent_node_coordinates);
		return;
	}

	int prior_depth = fringe->front->depth_of_node;

	/*Expand this node to find the successors*/
	find_and_add_successors_for_uniform_cost_search(&grid[row][col], grid_size, fringe->front->cost_from_root, false);

	/*Add this node to expanded list*/
	add_node_to_expanded_list(fringe->front->node_coordinates, fringe->front->parent_node_coordinates);

	/*Print the list of expanded nodes*/
	print_expanded_nodes();

	/*Clear this node from the fringe*/
	remove_front_of_queue(fringe);

	/*Navigate through all children/successors*/
	QNode* succ_list_pointer = grid[row][col].successors->front;
	int successors_count = grid[row][col].successors->size;

	for (int i = 0;i < successors_count;i++)
	{
		total_number_of_generated_nodes++;

		/*If this node is not already expanded or already present in the fringe, add this to end of fringe in priority queue implemetation*/
		if (!is_expanded_node(succ_list_pointer->node_coordinates))
		{
			if (!is_node_already_present_in_fringe(succ_list_pointer->node_coordinates))
			{
				add_in_increasing_queue(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, INVALID_VALUE);
			}
			/*If this node is already present in fringe, check if the path cost to this node is smaller or not. If yes, update the fringe with this new path cost of this given node*/
			else
			{
				update_fringe_node_with_less_cost(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, INVALID_VALUE);
			}
		}		
		succ_list_pointer = succ_list_pointer->next;
	}
	/*Recursive call*/
	uniform_cost_search(fringe, goal_coordinates);
}

/*****************************************************************************
* Function Description:
*
* Implements the depth first search algorithm
******************************************************************************/
void depth_first_search(Queue* fringe, Node_Coordinates goal_coordinates)
{
	/*Displays the fringe*/
	display_fringe(fringe, grid_size);

	/*If fringe is empty, search resulted in no path*/
	if (fringe->size == ZERO)
	{
		printf("\033[0;31m");
		printf("\nNo path exists to the goal position from  the robot position\n");
		printf("\033[0m");
		
		printf("\033[0;35m");
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");
	}

	else
	{
		/*Get the node present in the front of the fringe*/
		Node_Coordinates current_node = fringe->front->node_coordinates;

		int row = fringe->front->node_coordinates.row;
		int col = fringe->front->node_coordinates.column;

		int prior_depth = fringe->front->depth_of_node;

		/*Expand this node to find the successors*/
		find_and_add_successors(&grid[row][col], grid_size, fringe->front->cost_from_root);

		/*Add this node to expanded list*/
		add_node_to_expanded_list(fringe->front->node_coordinates, fringe->front->parent_node_coordinates);

		/*Print the list of expanded nodes*/
		print_expanded_nodes();

		/*Clear this node from the fringe*/
		remove_front_of_queue(fringe);

		/*Navigate through all children/successors*/
		QNode* succ_list_pointer = grid[row][col].successors->front;
		int successors_count = grid[row][col].successors->size;

		for (int i = 0;i < successors_count;i++)
		{
			total_number_of_generated_nodes++;

			/*If this node is a goal node, display the path from robot initial position to goal poisition and return success*/
			if (!is_expanded_node(succ_list_pointer->node_coordinates) && !is_node_already_present_in_fringe(succ_list_pointer->node_coordinates))
			{
				if (succ_list_pointer->node_coordinates.row == goal_coordinates.row && succ_list_pointer->node_coordinates.column == goal_coordinates.column)
				{
					display_fringe(fringe, grid_size);

					printf("\033[0;35m");
					printf("\nTotal cost = %f\n", succ_list_pointer->cost_from_root);
					printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
					printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
					printf("Depth explored = %d\n", prior_depth + 1);
					printf("\033[0m");

					generate_and_print_the_path(succ_list_pointer->parent_node_coordinates);
					return;
				}
				/*If this node is not already expanded or already present in the fringe, add this to start of fringe for LIFO implementation*/
				else
				{
					add_front_of_queue(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, INVALID_VALUE);
				}
			}
			succ_list_pointer = succ_list_pointer->next;
		}
		/*Recursive call*/
		depth_first_search(fringe, goal_coordinates);
	}
}
/*****************************************************************************
* Function Description:
*
* Implements the depth limited search algorithm
******************************************************************************/
Depth_limited_result depth_limited_search(Queue* fringe, Node_Coordinates goal_coordinates, int depth_limit)
{
	/*Displays the fringe*/
	display_fringe(fringe, grid_size);

	/*If fringe is empty, two possibilites:
	*	a. Tress explored fully (no solution exists)
	*	b. Cut off has been reached (all nodes within the limit has been expanded and checked)
	*/
	if (fringe->size == ZERO)
	{
		/*Case-a:*/
		if (explored_full_tree == true)
		{
			printf("\033[0;31m");
			printf("\nNo path exists\n");
			printf("\033[0m");

			printf("\033[0;35m");
			printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
			printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
			printf("\033[0m");
			return FAILURE;
		}
		/*Case-b:*/
		return CUT_OFF;
	}

	/*Get the node present in the front of the fringe*/
	Node_Coordinates current_node = fringe->front->node_coordinates;

	int row = fringe->front->node_coordinates.row;
	int col = fringe->front->node_coordinates.column;

	/*If this node is a goal node, display the path from robot initial position to goal poisition and return success*/
	if (row == goal_coordinates.row && col == goal_coordinates.column)
	{
		printf("\033[0;35m");
		printf("\nTotal cost = %f\n", fringe->front->cost_from_root);
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("Depth explored = %d\n", fringe->front->depth_of_node);
		printf("\033[0m");

		generate_and_print_the_path(fringe->front->parent_node_coordinates);
		return SUCCESS;;
	}

	/*If this node has reached the limit of expansion*/
	if (fringe->front->depth_of_node == depth_limit)
	{
		/*Just verify that tree has not been exhausted completely. 'True' = Had there been more limit to expand, tree would have expanded more.*/
		if (are_successors_present(fringe->front->node_coordinates, grid_size) == true)
		{
			explored_full_tree = false;
		}
		/*Clear this node from the fringe*/
		remove_front_of_queue(fringe);

		/*Continue with the remaining fringe*/
		return depth_limited_search(fringe, goal_coordinates, depth_limit);
	}

	/*If this node has not reached the limit of expansion and can be expanded further*/
	else
	{
		int prior_depth = fringe->front->depth_of_node;

		/*Expand this node to find the successors*/
		find_and_add_successors(&grid[row][col], grid_size, fringe->front->cost_from_root);

		/*Add this node to expanded list*/
		add_node_to_expanded_list(fringe->front->node_coordinates, fringe->front->parent_node_coordinates);

		/*Print the list of expanded nodes*/
		print_expanded_nodes();

		/*Clear this node from the fringe*/
		remove_front_of_queue(fringe);

		/*Navigate through all children/successors*/
		QNode* succ_list_pointer = grid[row][col].successors->front;
		int successors_count = grid[row][col].successors->size;

		for (int i = 0;i < successors_count;i++)
		{
			total_number_of_generated_nodes++;

			/*If this node is a goal node, display the path from robot initial position to goal poisition and return success*/
			if (!is_expanded_node(succ_list_pointer->node_coordinates) && !is_node_already_present_in_fringe(succ_list_pointer->node_coordinates))
			{
				if (succ_list_pointer->node_coordinates.row == goal_coordinates.row && succ_list_pointer->node_coordinates.column == goal_coordinates.column)
				{
					display_fringe(fringe, grid_size);

					printf("\033[0;35m");
					printf("\nTotal cost = %f\n", succ_list_pointer->cost_from_root);
					printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
					printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
					printf("Depth explored = %d\n", prior_depth + 1);
					printf("\033[0m");

					generate_and_print_the_path(succ_list_pointer->parent_node_coordinates);
					return SUCCESS;
				}
				/*If this node is not already expanded or already present in the fringe, add this to start of fringe for LIFO implementation*/
				else
				{
					add_front_of_queue(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, INVALID_VALUE);
				}
			}
			succ_list_pointer = succ_list_pointer->next;
		}
		/*Recursive call*/
		return depth_limited_search(fringe, goal_coordinates, depth_limit);
	}
}

/*****************************************************************************
* Function Description:
*
* Implements the iterative deepening search algorithm
******************************************************************************/
void iterative_deepening_search()
{
	Depth_limited_result result;
	int total_iterative_nodes = ZERO;
	int depth_limit;

	/*Infinite loop till either a path solution or path failure. Each step in a loop iteratively increase the depth of the tree*/
	for (depth_limit = 0; ;depth_limit++)
	{
		/*Reset the implementation based data structures and parameters*/
		total_number_of_generated_nodes = ZERO;

		if (depth_limit > 0)
		{
			delete_queue(expanded_nodes);
			delete_queue(fringe);
			expanded_nodes = createQueue();
			fringe = createQueue();
		}
		
		/*Add initial node as root*/
		add_front_of_queue(fringe, robot_mapped_coordinates, ZERO, dummy_invalid_coordinates, ZERO, INVALID_VALUE);
		total_number_of_generated_nodes++;

		explored_full_tree = true;

		/*Begin depth limited search with iterative incremental depth*/
		result = depth_limited_search(fringe, goal_mapped_coordinates, depth_limit);
		total_iterative_nodes += total_number_of_generated_nodes;

		/*If path is found or doesn't exist: stop the search. Else continue with increasing the depth iteratively*/
		if ( result != CUT_OFF)
		{
			printf("\033[0;35m");
			printf("Number of iterations in iterative deepening = %d\n", depth_limit + 1);
			printf("Overall total nodes generated in all iterations in iterative deepening = %d\n", total_iterative_nodes);
			printf("\033[0m");
			return result;
		}
	}
}

/*****************************************************************************
* Function Description:
*
* Implements the Greedy search algorithm
******************************************************************************/
void greedy_search()
{
	/*Displays the fringe*/
	display_fringe(fringe, grid_size);

	/*If fringe is empty, search resulted in no path*/
	if (fringe->size == ZERO)
	{
		printf("\033[0;31m");
		printf("\nNo path exists to the goal position from  the robot position\n");
		printf("\033[0m");
		printf("\033[0;35m");
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");
		return;
	}

	/*Get the node present in the front of the fringe*/
	Node_Coordinates current_node = fringe->front->node_coordinates;

	int row = fringe->front->node_coordinates.row;
	int col = fringe->front->node_coordinates.column;

	/*If this node is a goal node, display the path from robot initial position to goal poisition and return success*/
	if (row == goal_mapped_coordinates.row && col == goal_mapped_coordinates.column)
	{
		printf("\033[0;35m");
		printf("\nTotal cost = %f\n", fringe->front->cost_from_root);
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");

		generate_and_print_the_path(fringe->front->parent_node_coordinates);
		return;
	}

	int prior_depth = fringe->front->depth_of_node;

	/*Expand this node to find the successors*/
	find_and_add_successors_for_uniform_cost_search(&grid[row][col], grid_size, fringe->front->cost_from_root, false);

	/*Add this node to expanded list*/
	add_node_to_expanded_list(fringe->front->node_coordinates, fringe->front->parent_node_coordinates);

	/*Print the list of expanded nodes*/
	print_expanded_nodes();

	/*Clear this node from the fringe*/
	remove_front_of_queue(fringe);

	/*Navigate through all children/successors*/
	QNode* succ_list_pointer = grid[row][col].successors->front;
	int successors_count = grid[row][col].successors->size;

	for (int i = 0;i < successors_count;i++)
	{
		total_number_of_generated_nodes++;

		/*If this node is not already expanded or already present in the fringe, add this to end of fringe in priority queue implemetation*/
		if (!is_expanded_node(succ_list_pointer->node_coordinates))
		{
			if (!is_node_already_present_in_fringe(succ_list_pointer->node_coordinates))
			{
				add_in_increasing_queue(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, succ_list_pointer->evaluation_function_cost);
			}
			/*If this node is already present in fringe, check if the path cost to this node is smaller or not. If yes, update the fringe with this new path cost of this given node*/
			else
			{
				update_fringe_node_with_less_cost(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, succ_list_pointer->evaluation_function_cost);
			}
		}
		succ_list_pointer = succ_list_pointer->next;
	}
	/*Recursive call*/
	greedy_search();
}

/*****************************************************************************
* Function Description:
*
* Implements the A* search algorithm
******************************************************************************/
void a_star_search()
{
	/*Displays the fringe*/
	display_fringe(fringe, grid_size);

	/*If fringe is empty, search resulted in no path*/
	if (fringe->size == ZERO)
	{
		printf("\033[0;31m");
		printf("\nNo path exists to the goal position from  the robot position\n");
		printf("\033[0m");
		printf("\033[0;35m");
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");
		return;
	}

	/*Get the node present in the front of the fringe*/
	Node_Coordinates current_node = fringe->front->node_coordinates;

	int row = fringe->front->node_coordinates.row;
	int col = fringe->front->node_coordinates.column;

	/*If this node is a goal node, display the path from robot initial position to goal poisition and return success*/
	if (row == goal_mapped_coordinates.row && col == goal_mapped_coordinates.column)
	{
		printf("\033[0;35m");
		printf("\nTotal cost = %f\n", fringe->front->cost_from_root);
		printf("Total number of expanded nodes = %d\n", expanded_nodes->size);
		printf("Total number of nodes generated = %d\n", total_number_of_generated_nodes);
		printf("\033[0m");

		generate_and_print_the_path(fringe->front->parent_node_coordinates);
		return;
	}

	int prior_depth = fringe->front->depth_of_node;

	/*Expand this node to find the successors*/
	find_and_add_successors_for_uniform_cost_search(&grid[row][col], grid_size, fringe->front->cost_from_root, true);

	/*Add this node to expanded list*/
	add_node_to_expanded_list(fringe->front->node_coordinates, fringe->front->parent_node_coordinates);

	/*Print the list of expanded nodes*/
	print_expanded_nodes();

	/*Clear this node from the fringe*/
	remove_front_of_queue(fringe);

	/*Navigate through all children/successors*/
	QNode* succ_list_pointer = grid[row][col].successors->front;
	int successors_count = grid[row][col].successors->size;

	for (int i = 0;i < successors_count;i++)
	{
		total_number_of_generated_nodes++;

		/*If this node is not already expanded or already present in the fringe, add this to end of fringe in priority queue implemetation*/
		if (!is_expanded_node(succ_list_pointer->node_coordinates))
		{
			if (!is_node_already_present_in_fringe(succ_list_pointer->node_coordinates))
			{
				add_in_increasing_queue(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, succ_list_pointer->evaluation_function_cost);
			}
			/*If this node is already present in fringe, check if the path cost to this node is smaller or not. If yes, update the fringe with this new path cost of this given node*/
			else
			{
				update_fringe_node_with_less_cost(fringe, succ_list_pointer->node_coordinates, succ_list_pointer->cost_from_root, current_node, prior_depth + 1, succ_list_pointer->evaluation_function_cost);
			}
		}
		succ_list_pointer = succ_list_pointer->next;
	}
	/*Recursive call*/
	a_star_search();
}


/*****************************************************************************
* Function Description:
*
* Initial configurations before the search algorithm
******************************************************************************/
bool initial_operations(bool first_cycle)
{
	int menu_selection;
	int retry_attempts = MAX_INPUT_ATTEMPTS;
	int entered_row, entered_col;
	int goal_row, goal_col;
	int diagonal_cost;


	
	/*Get the menu selection from the user*/
	while (retry_attempts > ZERO)
	{
		if (first_cycle)
		{
			printf("Please select:\n1. Give new input data.\n0.Exit\n\n");
		}
		else
		{
			printf("\n\nPlease select:\n1. Give new input data.\n2. Search again on the current grid\n0.Exit\n\n");
		}

		scanf("%d", &menu_selection);
		printf("Your choice: %d\n", menu_selection);

		if (first_cycle)
		{
			if ((valid_input(menu_selection, ZERO)) || (valid_input(menu_selection, ONE)))
			{
				break;
			}
			else
			{
				printf("Invalid input is entered, please try again\n");
				retry_attempts--;
			}
		}
		else
		{
			if ((valid_input(menu_selection, ZERO)) || (valid_input(menu_selection, ONE)) || (valid_input(menu_selection, TWO)))
			{
				break;
			}
			else
			{
				printf("Invalid input is entered, please try again\n");
				retry_attempts--;
			}
		}
	}

	if (retry_attempts == ZERO)
	{
		printf("Ran out of maximum attempts for entering valid input. Closing the application\n");
		return 0;
	}

	if (menu_selection == ZERO)
	{
		/*Exit the search program*/
		return false;
	}
	/*Reset the common global parameters*/
	reset_parameters();

	if (menu_selection == 1)
	{
		reset_grid();

		printf("\nPlease, give size of the grid : ");
		scanf("%d", &grid_size);

		/*Allocate memory to the grid*/
		grid = (Grid_Node**)malloc(grid_size * sizeof(Grid_Node*));
		
		for (int i = 0; i < grid_size; i++)
		{
			grid[i] = (Grid_Node*)malloc(grid_size * sizeof(Grid_Node));
		}

		printf("\nPlease, give the grid ('X'for obstacles, '.' for empty cells): \n");
		for (int i = 0; i < grid_size; i++)
		{
			char* grid_arr = (char*)calloc(grid_size+1, sizeof(char));
			fgets(grid_arr,grid_size,stdin);
			fgets(grid_arr, grid_size+1, stdin);

			if (strlen(grid_arr) != grid_size)
			{
				printf("Invalid input, enter again\n");
				fgets(grid_arr, grid_size + 1, stdin);(grid_arr);
			}

			for (int j = 0; j < grid_size; j++)
			{
				grid[i][j].cell_type				= grid_arr[j];
				grid[i][j].cell_coordinates.row		= i;
				grid[i][j].cell_coordinates.column	= j;
				grid[i][j].cost						= DEFAULT_INITIAL_COST_OF_NODE;
			}
			free(grid_arr);
		}
	}

	for (int i = 0; i < grid_size; i++)
	{
		for (int j = 0;j < grid_size;j++)
		{
			grid[i][j].successors = createQueue();
		}
	}
	
	char* coordinate_input = NULL;
	const char s[2] = " ";
	char* token;

	if (coordinate_input == NULL)
	{
		coordinate_input = malloc(4 * sizeof(char));
	}

	printf("\nPlease, give start position of the robot(column and row, numbering columns starting from 1 left to right and rows starting from 1 down to up) : ");

	fgets(coordinate_input, 4, stdin);
	fgets(coordinate_input, 4, stdin);

	/* get the first token */
	token = strtok(coordinate_input, s);
	entered_col = atoi(token);

	/* get the second token */
	token = strtok(NULL, s);
	entered_row = atoi(token);

	robot_mapped_coordinates.row	= grid_size - entered_row;
	robot_mapped_coordinates.column = entered_col - 1;

	printf("\nPlease, give goal cell (same convention as previously): ");
	fgets(coordinate_input, 4, stdin);
	fgets(coordinate_input, 4, stdin);

	/* get the first token */
	token = strtok(coordinate_input, s);
	goal_col = atoi(token);

	/* get the second token */
	token = strtok(NULL, s);
	goal_row = atoi(token);

	goal_mapped_coordinates.row		= grid_size - goal_row;
	goal_mapped_coordinates.column	= goal_col - 1;

	free(coordinate_input);

	printf("\nYour grid is (R is robot, G is goal cell):\n");
	
	printf("\n  ");
	for (int i = 0;i < grid_size;i++)
	{
		printf("    %d", i + 1);
	}
	printf("\n");
	for (int i = 0;i < grid_size;i++)
	{
		printf("________");
	}
	
	for (int i = 0;i < grid_size;i++)
	{
		printf("\t\n |\n |\n%d|    ",grid_size-i);
		for (int j = 0;j < grid_size;j++)
		{
			if (i == robot_mapped_coordinates.row && j == robot_mapped_coordinates.column)
			{
				printf("R    ");
			}
			else if (i == goal_mapped_coordinates.row && j == goal_mapped_coordinates.column)
			{
				printf("G    ");
			}
			else
			{
				printf("%c    ", grid[i][j].cell_type);
			}
		}
	}
	printf("\n\n");

	printf("Are diagonal move allowed(yes/no): ");
	if (diagonal_movement_allowed == NULL)
	{
		diagonal_movement_allowed = malloc(3 * sizeof(char));
	}
	scanf("%s", diagonal_movement_allowed);

	if (strcmp(diagonal_movement_allowed, "yes") == 0)
	{
		printf("\nPress 1 if diagonal cost equals to 1 or 2 if diagonal cost equals to 1.5: ");
		scanf("%d", &diagonal_cost);

		if (diagonal_cost == 1)
		{
			diagonal_movement_cost = 1;
		}
		else
		{
			diagonal_movement_cost = DIAGONAL_MOVEMENT_COST_MAX;
		}
		selected_heuristic_type = CHEBYSHEV_DISTANCE;
	}
	else
	{
		selected_heuristic_type = MANHATTAN_DISTANCE;
	}

	
	return true;
	
}
int main()
{
	dummy_invalid_coordinates.row = INVALID_VALUE;
	dummy_invalid_coordinates.column = INVALID_VALUE;

	int method_choice;
	bool result;

	result = initial_operations(true);
	while (result)
	{
		fringe			= createQueue();
		expanded_nodes	= createQueue();
		path			= createQueue();

		if ((strcmp(diagonal_movement_allowed, "yes") == 0) && diagonal_movement_cost == DIAGONAL_MOVEMENT_COST_MAX)
		{
			printf("\nPlease, select method\n1. Breadth first\n2. Uniform cost\n3. Depth first\n5. Greedy\n6. A * \n\n");
		}
		else
		{
			printf("\nPlease, select method\n1. Breadth first\n3. Depth first\n4. Iterative deepening\n5. Greedy\n6. A * \n\n");
		}
		scanf("%d", &method_choice);
		printf("Your choice: %d\n", method_choice);

		switch (method_choice)
		{
			case 1:
			{
				if (robot_mapped_coordinates.row == goal_mapped_coordinates.row && robot_mapped_coordinates.column == goal_mapped_coordinates.column)
				{
					total_number_of_generated_nodes++;
					int remapped_row = grid_size - goal_mapped_coordinates.row;
					int remapped_col = goal_mapped_coordinates.column + 1;

					printf("\nNo movement needed. Already in a goal position");
					printf("\nFringe State: EMPTY FRINGE");
					printf("\nExpanded Nodes: EMPTY SET");
					printf("Total cost = 0\n");
					printf("Total number of expanded nodes= %d\n", expanded_nodes->size);
					printf("Total number of nodes filled in fringe= %d\n", total_number_of_generated_nodes);
				}
				else
				{
					add_end_of_queue(fringe, robot_mapped_coordinates, ZERO, dummy_invalid_coordinates, ZERO, INVALID_VALUE);
					total_number_of_generated_nodes++;
					print_expanded_nodes();
					breadth_first_search(fringe, goal_mapped_coordinates);
				}
				break;
			}

			case 2:
			{
				if ((strcmp(diagonal_movement_allowed, "yes") == 0) && (diagonal_movement_cost == DIAGONAL_MOVEMENT_COST_MAX))
				{
					if (robot_mapped_coordinates.row == goal_mapped_coordinates.row && robot_mapped_coordinates.column == goal_mapped_coordinates.column)
					{
						total_number_of_generated_nodes++;
						int remapped_row = grid_size - goal_mapped_coordinates.row;
						int remapped_col = goal_mapped_coordinates.column + 1;

						printf("\nNo movement needed. Already in a goal position");
						printf("\nFringe State: EMPTY FRINGE");
						printf("\nExpanded Nodes: EMPTY SET");
						printf("Total cost = 0\n");
						printf("Total number of expanded nodes= %d\n", expanded_nodes->size);
						printf("Total number of nodes filled in fringe= %d\n", total_number_of_generated_nodes);
					}
					else
					{
						add_in_increasing_queue(fringe, robot_mapped_coordinates, ZERO, dummy_invalid_coordinates, ZERO, INVALID_VALUE);
						total_number_of_generated_nodes++;
						print_expanded_nodes();
						uniform_cost_search(fringe, goal_mapped_coordinates);
					}
				}
				else
				{
					printf("\nInvalid case: Uniform cost search can only be used for the case of diagnonal movement with 1.5 cost.");
				}
				break;
			}

			case 3:
			{
				if (robot_mapped_coordinates.row == goal_mapped_coordinates.row && robot_mapped_coordinates.column == goal_mapped_coordinates.column)
				{
					total_number_of_generated_nodes++;
					int remapped_row = grid_size - goal_mapped_coordinates.row;
					int remapped_col = goal_mapped_coordinates.column + 1;

					printf("\nNo movement needed. Already in a goal position");
					printf("\nFringe State: EMPTY FRINGE");
					printf("\nExpanded Nodes: EMPTY SET");
					printf("Total cost = 0\n");
					printf("Total number of expanded nodes= %d\n", expanded_nodes->size);
					printf("Total number of nodes filled in fringe= %d\n", total_number_of_generated_nodes);
				}
				else
				{
					add_front_of_queue(fringe, robot_mapped_coordinates, ZERO, dummy_invalid_coordinates, ZERO, INVALID_VALUE);
					total_number_of_generated_nodes++;
					print_expanded_nodes();
					depth_first_search(fringe, goal_mapped_coordinates);
				}
				break;
			}

			case 4:
			{
				if((strcmp(diagonal_movement_allowed, "yes") == 0) && (diagonal_movement_cost == DIAGONAL_MOVEMENT_COST_MAX))
				{
					printf("\nInvalid case: Iterative Deepening search can not be used for the case of diagnonal movement with 1.5 cost.");
				}
				else
				{
					if (robot_mapped_coordinates.row == goal_mapped_coordinates.row && robot_mapped_coordinates.column == goal_mapped_coordinates.column)
					{
						total_number_of_generated_nodes++;
						int remapped_row = grid_size - goal_mapped_coordinates.row;
						int remapped_col = goal_mapped_coordinates.column + 1;

						printf("\nNo movement needed. Already in a goal position");
						printf("\nFringe State: EMPTY FRINGE");
						printf("\nExpanded Nodes: EMPTY SET");
						printf("Total cost = 0\n");
						printf("Total number of expanded nodes= %d\n", expanded_nodes->size);
						printf("Total number of nodes filled in fringe= %d\n", total_number_of_generated_nodes);
					}
					else
					{
						iterative_deepening_search();
					}
				}
				break;
			}

			case 5:
			{
				if (robot_mapped_coordinates.row == goal_mapped_coordinates.row && robot_mapped_coordinates.column == goal_mapped_coordinates.column)
				{
					total_number_of_generated_nodes++;
					int remapped_row = grid_size - goal_mapped_coordinates.row;
					int remapped_col = goal_mapped_coordinates.column + 1;

					printf("\nNo movement needed. Already in a goal position");
					printf("\nFringe State: EMPTY FRINGE");
					printf("\nExpanded Nodes: EMPTY SET");
					printf("Total cost = 0\n");
					printf("Total number of expanded nodes= %d\n", expanded_nodes->size);
					printf("Total number of nodes filled in fringe= %d\n", total_number_of_generated_nodes);
				}
				else
				{
					float evaluation_function = calculate_heuristic(robot_mapped_coordinates, goal_mapped_coordinates, selected_heuristic_type);
					add_front_of_queue(fringe, robot_mapped_coordinates, ZERO, dummy_invalid_coordinates, ZERO, evaluation_function);
					total_number_of_generated_nodes++;
					print_expanded_nodes();
					greedy_search();
				}
				break;
			}

			case 6:
			{
				if (robot_mapped_coordinates.row == goal_mapped_coordinates.row && robot_mapped_coordinates.column == goal_mapped_coordinates.column)
				{
					total_number_of_generated_nodes++;
					int remapped_row = grid_size - goal_mapped_coordinates.row;
					int remapped_col = goal_mapped_coordinates.column + 1;

					printf("\nNo movement needed. Already in a goal position");
					printf("\nFringe State: EMPTY FRINGE");
					printf("\nExpanded Nodes: EMPTY SET");
					printf("Total cost = 0\n");
					printf("Total number of expanded nodes= %d\n", expanded_nodes->size);
					printf("Total number of nodes filled in fringe= %d\n", total_number_of_generated_nodes);
				}
				else
				{
					float evaluation_function = calculate_heuristic(robot_mapped_coordinates, goal_mapped_coordinates, selected_heuristic_type);
					add_front_of_queue(fringe, robot_mapped_coordinates, ZERO, dummy_invalid_coordinates, ZERO, evaluation_function);
					total_number_of_generated_nodes++;
					print_expanded_nodes();
					a_star_search();
				}
				break;
			}

			default:
			{
				break;
			}
		}

		result = initial_operations(false);
	}
	reset_parameters();
	reset_grid();
}